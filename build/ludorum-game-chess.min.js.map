{"version":3,"sources":["../src/__prologue__.js","../src/Chess.js","../src/__epilogue__.js"],"names":["__init__","base","Sermat","ludorum","ChessJS","declare","iterable","UserInterface","players","Chess","CHESS","INITIAL_FEN","fen","chessjs_package","__package__","__name__","eval","__dependencies__","exports","__SERMAT__","include","syncGlobalChess","__currentFEN__","load","Game","name","constructor","params","this","globalChess","call","turn","moves","options","r","game_over","activePlayer","next","haps","update","raiseIf","move","result","in_checkmate","defeat","tied","static __SERMAT__","identifier","serializer","obj","clone","toString","toFEN","static fromFEN","str","square","PIECES","p","n","b","q","k","coord","Array","isArray","charAt","get","player","color","type","static heuristics","games","push"],"mappings":";;+VAEA,SAASA,SAASC,KAAMC,OAAQC,QAASC,SAAW,aAEnD,IAAIC,QAAUJ,KAAKI,QAClBC,SAAWL,KAAKK,SAChBC,cAAgBJ,QAAQK,QAAQD,cAGV,iBAAZH,UACVA,QAAUA,QAAQK,OAEnB,IAAIC,MAAQN,UACXO,YAAcD,MAAME,MAGjBC,iBACFC,YAAa,WACbC,SAAU,UACVf,SAAUgB,KAAI,kCAAoCZ,QAAQ,SAC1Da,qBAEDC,SACCJ,YAAa,qBACbC,SAAU,qBACVf,SAAUA,SACViB,kBAAmBhB,KAAMC,OAAQC,QAASU,iBAC1CM,YAAcC,SAAUnB,KAAME,WCtBjC,SAASkB,gBAAgBT,GAMxB,OALAA,EAAMA,GAAOD,YACTD,MAAMY,iBAAmBV,IAC5BF,MAAMa,KAAKX,GACXF,MAAMY,eAAiBV,GAEjBF,MAGR,IAAID,MAAQS,QAAQT,MAAQJ,QAAQF,QAAQqB,MAC3CC,KAAM,QAINjB,SAAS,QAAU,SAKnBkB,YAAa,SAAeC,GAC3BC,KAAKhB,IAAMe,GAAUA,EAAOf,KAAOD,YACnC,IAAIkB,EAAcR,gBAAgBO,KAAKhB,KACvCT,QAAQqB,KAAKM,KAAKF,KAAMA,KAAKpB,QAA+B,MAAvBqB,EAAYE,OAAiB,EAAI,KAQvEC,MAAO,SAAeC,GACrB,IAAIJ,EAAcR,gBAAgBO,KAAKhB,KACtCsB,EAAI,KAKL,OAJKL,EAAYM,eAChBD,MACEN,KAAKQ,gBAAkBP,EAAYG,MAAMC,IAErCC,GAKRG,KAAM,SAAcL,EAAOM,EAAMC,GAChCtC,KAAKuC,QAAQF,EAAM,gCAAiCA,EAAM,MAC1D,IAAIT,EAAcR,gBAAgBO,KAAKhB,KAEvC,OADAiB,EAAYY,KAAKT,EAAMJ,KAAKQ,iBACxBG,GACHX,KAAKhB,IAAMiB,EAAYjB,MAChBgB,MAEA,IAAIA,KAAKF,aAAcd,IAAKiB,EAAYjB,SAMjD8B,OAAQ,WACP,IAAIb,EAAcR,gBAAgBO,KAAKhB,KACvC,OAAKiB,EAAYM,YAENN,EAAYc,eACff,KAAKgB,SAELhB,KAAKiB,OAJL,MAYTC,qBACCC,WAAY,QACZC,WAAY,SAAyBC,GACpC,QAAUrC,IAAKqC,EAAIrC,QAIrBsC,MAAO,WACN,OAAO,IAAItB,KAAKF,YAAYE,KAAKhB,MAMlCuC,SAAU,WACT,OAAOvB,KAAKwB,SAGbA,MAAO,WACN,OAAOxB,KAAKhB,KAMbyC,iBAAkB,SAAiBC,GAClC,OAAO,IAAI1B,MAAOhB,IAAKgB,KAAKhB,OAG7B2C,QACKC,QACHC,EAAG,OAAQC,EAAG,SAAUC,EAAG,SAAUzB,EAAG,OAAQ0B,EAAG,QAASC,EAAG,QAEzD,SAAgBC,GAClBC,MAAMC,QAAQF,KACjBA,EAAQ,WAAWG,OAAOH,EAAM,KAAOA,EAAM,GAAK,IAEnD,IACC5B,EADiBb,gBAAgBO,KAAKhB,KACtBsD,IAAIJ,GAKrB,OAJI5B,IACHA,EAAEiC,OAASvC,KAAKpB,QAAoB,MAAZ0B,EAAEkC,MAAgB,EAAI,GAC9ClC,EAAET,KAAO+B,OAAOtB,EAAEmC,OAEZnC,IASToC,yBAtBKd,OCzGL,ODsIDrD,QAAQoE,MAAM9D,MAAQA,MAItBA,MAAMU,WAAW4B,WAAa7B,QAAQJ,YAAY,IAAML,MAAMU,WAAW4B,WACzE7B,QAAQC,WAAWC,QAAQoD,KAAK/D,OAChCP,OAAOkB,QAAQF,SC5IPA","file":"ludorum-game-chess.min.js","sourcesContent":["/** Package wrapper and layout.\n*/\nfunction __init__(base, Sermat, ludorum, ChessJS) { \"use strict\";\n// Import synonyms. ////////////////////////////////////////////////////////////////////////////////\n\tvar declare = base.declare,\n\t\titerable = base.iterable,\n\t\tUserInterface = ludorum.players.UserInterface;\n\n// Workaround for difference in module definition depending on platform. ///////////////////////////\n\tif (typeof ChessJS === 'object') {\n\t\tChessJS = ChessJS.Chess;\n\t}\n\tvar CHESS = ChessJS(),\n\t\tINITIAL_FEN = CHESS.fen();\n\n// Library layout. /////////////////////////////////////////////////////////////////////////////////\n\tvar chessjs_package = {\n\t\t\t__package__: 'chess.js',\n\t\t\t__name__: 'ChessJS',\n\t\t\t__init__: eval('(function __init__() { return ('+ ChessJS +'); })'),\n\t\t\t__dependencies__: []\n\t\t},\n\t\texports = {\n\t\t\t__package__: 'ludorum-game-chess',\n\t\t\t__name__: 'ludorum_game_chess',\n\t\t\t__init__: __init__,\n\t\t\t__dependencies__: [base, Sermat, ludorum, chessjs_package],\n\t\t\t__SERMAT__: { include: [base, ludorum] }\n\t\t};\n","/** # Chess\n\nImplementation of [Chess](http://www.fide.com/component/handbook/?id=124&view=article) for Ludorum.\n*/\n\nfunction syncGlobalChess(fen) {\n\tfen = fen || INITIAL_FEN;\n\tif (CHESS.__currentFEN__ !== fen) {\n\t\tCHESS.load(fen);\n\t\tCHESS.__currentFEN__ = fen;\n\t}\n\treturn CHESS;\n}\n\nvar Chess = exports.Chess = declare(ludorum.Game, {\n\tname: 'Chess',\n\n\t/** The game is played by two players: White and Black. White moves first.\n\t*/\n\tplayers: [\"White\", \"Black\"],\n\n\t/** The constructor takes the `activePlayer` (`\"White\"` by default), and the `board` as an\n\tinstance of `CheckerboardFromPieces` (with the initial setup by default).\n\t*/\n\tconstructor: function Chess(params){\n\t\tthis.fen = params && params.fen || INITIAL_FEN;\n\t\tvar globalChess = syncGlobalChess(this.fen);\n\t\tludorum.Game.call(this, this.players[globalChess.turn() === 'w' ? 0 : 1]);\n\t},\n\n\t// ## Game methods #############################################################################\n\n\t/** A move always places a piece in an empty square, if and only if by doing so one or more\n\tlines of the opponent's pieces get enclosed between pieces of the active player.\n\t*/\n\tmoves: function moves(options) {\n\t\tvar globalChess = syncGlobalChess(this.fen),\n\t\t\tr = null;\n\t\tif (!globalChess.game_over()) {\n\t\t\tr = {};\n\t\t\tr[this.activePlayer()] = globalChess.moves(options);\n\t\t}\n\t\treturn r;\n\t},\n\n\t/** TODO.\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\tbase.raiseIf(haps, 'Haps are not required (given ', haps, ')!');\n\t\tvar globalChess = syncGlobalChess(this.fen);\n\t\tglobalChess.move(moves[this.activePlayer()]);\n\t\tif (update) {\n\t\t\tthis.fen = globalChess.fen();\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new this.constructor({ fen: globalChess.fen() });\n\t\t}\n\t},\n\n\t/** TODO.\n\t*/\n\tresult: function result() {\n\t\tvar globalChess = syncGlobalChess(this.fen);\n\t\tif (!globalChess.game_over()) {\n\t\t\treturn null;\n\t\t} else if (globalChess.in_checkmate()) {\n\t\t\treturn this.defeat();\n\t\t} else {\n\t\t\treturn this.tied();\n\t\t}\n\t},\n\n\t// ## Utility methods ##########################################################################\n\n\t/** The game state serialization uses [Forsyth–Edwards notation](http://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation).\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Chess',\n\t\tserializer: function serialize_Chess(obj) {\n\t\t\treturn [{ fen: obj.fen }];\n\t\t}\n\t},\n\n\tclone: function clone() {\n\t\treturn new this.constructor(this.fen);\n\t},\n\n\t/** The default string representation of Chess is the\n\t[Forsyth–Edwards notation](http://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation).\n\t*/\n\ttoString: function toString() {\n\t\treturn this.toFEN();\n\t},\n\n\ttoFEN: function toFEN() {\n\t\treturn this.fen;\n\t},\n\n\t/** The `fromFEN` function parses a string in [Forsyth–Edwards notation](http://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation)\n\tand builds the corresponding game state.\n\t*/\n\t'static fromFEN': function fromFEN(str) {\n\t\treturn new this({ fen: this.fen });\n\t},\n\n\tsquare: (function () {\n\t\tvar PIECES = {\n\t\t\tp: 'Pawn', n: 'Knight', b: 'Bishop', r: 'Rook', q: 'Queen', k: 'King'\n\t\t};\n\t\treturn function square(coord) {\n\t\t\tif (Array.isArray(coord)) {\n\t\t\t\tcoord = 'abcdefgh'.charAt(coord[1]) + (coord[0] + 1);\n\t\t\t}\n\t\t\tvar globalChess = syncGlobalChess(this.fen),\n\t\t\t\tr = globalChess.get(coord);\n\t\t\tif (r) {\n\t\t\t\tr.player = this.players[r.color === 'w' ? 0 : 1];\n\t\t\t\tr.name = PIECES[r.type];\n\t\t\t}\n\t\t\treturn r;\n\t\t};\n\t})(),\n\n\t// ## Heuristics ###############################################################################\n\n\t/** `Chess.heuristics` is a bundle of helper functions to build heuristic evaluation functions\n\tfor this game.\n\t*/\n\t'static heuristics': {\n\t\t// TODO\n\t}\n}); // declare Othello.\n\n/** Adding Chess to `ludorum.games`.\n*/\nludorum.games.Chess = Chess;\n\n/** Sermat serialization.\n*/\nChess.__SERMAT__.identifier = exports.__package__ +'.'+ Chess.__SERMAT__.identifier;\nexports.__SERMAT__.include.push(Chess);\nSermat.include(exports);\n","// See __prologue__.js\n\treturn exports;\n}\n"]}